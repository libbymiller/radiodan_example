#!/usr/bin/env ruby
require 'wiringpi2'
require 'pp'

class Button

  INPUT = 0
  INT_EDGE_RISING = 1
  INT_EDGE_FALLING = 2
  INT_EDGE_BOTH = 3
  PUD_UP = 2
  attr_accessor :pin, :value

  def initialize(pin, io)
    @pin = pin
    puts "pin is #{@pin}"
    io.pin_mode(@pin,INPUT)
    io.pullUpDnControl(@pin, PUD_UP)
    io.wiringpi_isr(@pin, INT_EDGE_BOTH, update(io))
  end

  def update(io)
    self.value = io.digital_read(self.pin)
    return nil
  end

end

pin = 0
io = WiringPi::GPIO.new
button = Button.new(pin,io)
last_val = nil

ROOT = File.join(File.dirname(__FILE__), '..')
PATH  = File.join(ROOT, 'tmp')

while (true)
    button.update(io)
    if(button.value!=last_val)
      puts button.value
      last_val = button.value
      if(button.value==0)
           puts "CHANGING CHANNEL!"
           filename = File.join(PATH, "change_channel")
           File.open(filename, 'w') { |file| file.write(Time.now) }

           last_tracks_str = File.read("#{ROOT}/stations.txt")
           was_playing_str = File.read("#{ROOT}/to_play.txt")
           station = was_playing_str.split("\t")[0]

           contents = last_tracks_str.chomp
           arr = contents.split("\n")
           count = 0
           arr.each do |a|
             arr2 = a.split("\t")
             if(arr2[0]==station) #take the next one
               next_station = arr[count+1]
               if(next_station && next_station != "")
                  puts "found new station #{next_station}"
                  File.open("#{ROOT}/to_play.txt", 'w') {|f| f.write(next_station) }
               else
                  next_station = arr[0]
                  puts "starting list of stations again #{next_station}"
                  File.open("#{ROOT}/to_play.txt", 'w') {|f| f.write(next_station) }
               end
             end
             count = count + 1
           end

      end
    end
end

